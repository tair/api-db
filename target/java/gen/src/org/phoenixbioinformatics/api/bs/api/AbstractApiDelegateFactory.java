/**
 * Copyright 2011 Carnegie Institution for Science. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractSubsystemDelegateFactory.vsl

package org.phoenixbioinformatics.api.bs.api;


import com.poesys.db.connection.IConnectionFactory.DBMS;


/**
 * <p>
 * A set of factory methods for the instantiable business delegates in the 
 * Api subsystem. This class is abstract and has a single concrete 
 * subclass, ApiDelegateFactory, that you can modify to override
 * the default behavior in the abstract class or implement an as-yet 
 * unimplemented delegate factory. You can, for example, override all the
 * factory methods with a different connection strategy.
 * </p>
 * <p>
 * the API relating to the software systems presented to parties as a single unit
 * for subscription
 * </p>
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractApiDelegateFactory {
  /** 
   * The fully qualified name of the Api subsystem properties file,
   * not including the locale information. This comes from the UML subsystem
   * as the package name concatenated to the subsystem name (the fully qualified
   * subsystem name). The actual file is then in the package with the subsystem 
   * name concatenated to the locale name followed by the .properties extension.
   * For example, the subsystem api in the org.phoenixbioinformatics.api.db 
   * package has the property file org.phoenixbioinformatics.api.db.api_en_US.properties
   * for the default locale english (US).
   */
  private static final String PROPERTY_FILE = "org.phoenixbioinformatics.api.db.api";
    
  /** Resource bundle for subsystem property file */
  private static final java.util.ResourceBundle rb =
    java.util.ResourceBundle.getBundle(PROPERTY_FILE);

  /** Initialize the subsystem name from the property file. */
  private static final String subsystem = rb.getString("subsystem");

  /** Initialize the DBMS type from the property file. */
  protected static final DBMS JNDI_DBMS = DBMS.stringValue(rb.getString("jndi_dbms"));
  
  /** Initialize the cached DAO manager for the subsystem. */
  protected static final com.poesys.db.dao.IDaoManager manager = 
    com.poesys.db.dao.DaoManagerFactory.initCacheManager(subsystem);

  /**
   * Get the PartnerDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static PartnerDelegate getPartnerDelegate() {
    return new PartnerDelegate(subsystem);
  }
  
  /**
   * Get the PartnerDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static PartnerDelegate getJndiPartnerDelegate() {
    return new PartnerDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the ApiKeyDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static ApiKeyDelegate getApiKeyDelegate() {
    return new ApiKeyDelegate(subsystem);
  }
  
  /**
   * Get the ApiKeyDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static ApiKeyDelegate getJndiApiKeyDelegate() {
    return new ApiKeyDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the AccessTypeDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static AccessTypeDelegate getAccessTypeDelegate() {
    return new AccessTypeDelegate(subsystem);
  }
  
  /**
   * Get the AccessTypeDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static AccessTypeDelegate getJndiAccessTypeDelegate() {
    return new AccessTypeDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the UriPatternDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static UriPatternDelegate getUriPatternDelegate() {
    return new UriPatternDelegate(subsystem);
  }
  
  /**
   * Get the UriPatternDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static UriPatternDelegate getJndiUriPatternDelegate() {
    return new UriPatternDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the PageViewDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static PageViewDelegate getPageViewDelegate() {
    return new PageViewDelegate(subsystem);
  }
  
  /**
   * Get the PageViewDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static PageViewDelegate getJndiPageViewDelegate() {
    return new PageViewDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the PartyDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static PartyDelegate getPartyDelegate() {
    return new PartyDelegate(subsystem);
  }
  
  /**
   * Get the PartyDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static PartyDelegate getJndiPartyDelegate() {
    return new PartyDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the CountryDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static CountryDelegate getCountryDelegate() {
    return new CountryDelegate(subsystem);
  }
  
  /**
   * Get the CountryDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static CountryDelegate getJndiCountryDelegate() {
    return new CountryDelegate(subsystem, JNDI_DBMS);
  }

  /**
   * Get the ActivationCodeDelegate. The file Api.properties supplies the
   * database subsystem for the delegate to use. The method enables caching and
   * constructs the Delegate with the subsystem from the property file. The
   * database and password are set from the database properties file entries
   * for the subsystem. Use this method in contexts where you don't know 
   * whether a JNDI server will be available, such as lazy loading contexts or
   * JUnit test cases.
   * 
   * @return the delegate
   */
  public static ActivationCodeDelegate getActivationCodeDelegate() {
    return new ActivationCodeDelegate(subsystem);
  }
  
  /**
   * Get the ActivationCodeDelegate using the JNDI_DBMS static member initialized
   * from the Api.properties file. The system uses the JNDI name to
   * access the data source. Use this method in contexts where you know that
   * the JNDI server will always be available.
   * 
   * @return the JNDI delegate
   */
  public static ActivationCodeDelegate getJndiActivationCodeDelegate() {
    return new ActivationCodeDelegate(subsystem, JNDI_DBMS);
  }
}